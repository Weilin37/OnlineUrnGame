{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport { useLeaflet } from \"react-leaflet\";\nimport L from 'leaflet';\nimport '@elfalem/leaflet-curve';\nimport { useSelector } from \"react-redux\";\nimport haversine from 'haversine-distance';\n\nconst Arches = () => {\n  _s();\n\n  const {\n    map\n  } = useLeaflet();\n  const stateMarker = useSelector(state => state.marker);\n  var factor = 1;\n  const factordelta = 0.1;\n\n  function calculateCurve(lat1, lng1, lat2, lng2, factor, weight) {\n    var latlng1 = [lat1, lng1];\n    var latlng2 = [lat2, lng2];\n    var offsetX = latlng2[1] - latlng1[1];\n    var offsetY = latlng2[0] - latlng1[0];\n    var r = Math.sqrt(Math.pow(offsetX, 2) + Math.pow(offsetY, 2)),\n        theta = Math.atan2(offsetY, offsetX);\n    var thetaOffset = 3.14 / 10 * factor;\n    var r2 = r / 2 / Math.cos(thetaOffset);\n    var theta2 = theta + thetaOffset;\n    var midpointX = r2 * Math.cos(theta2) + latlng1[1];\n    var midpointY = r2 * Math.sin(theta2) + latlng1[0];\n    var midpointLatLng = [midpointY, midpointX];\n    var durationBase = 2000;\n    var duration = Math.sqrt(Math.log(r)) * durationBase;\n\n    if (isNaN(duration)) {\n      duration = durationBase;\n    }\n\n    var pathOptions = {\n      weight: weight,\n      opacity: 0.15\n    };\n    /*pathOptions.animate = {\r\n        duration: duration,\r\n        iterations: Infinity,\r\n        easing: 'ease-in-out',\r\n        direction: 'normal'\r\n    }*/\n\n    return {\n      'latlng1': latlng1,\n      'midpointLatLng': midpointLatLng,\n      'latlng2': latlng2,\n      'pathOptions': pathOptions\n    };\n  }\n\n  function calculateDistance(lat1, lng1, lat2, lng2) {\n    return Math.sqrt((lat1 - lat2) ** 2 + (lng1 - lng2) ** 2);\n  }\n\n  for (var i = 0; i < stateMarker.filtered_data.length; i++) {\n    var lat1 = stateMarker.filtered_data[i].origin_latitude;\n    var lng1 = stateMarker.filtered_data[i].origin_longitude;\n    var lat2 = stateMarker.filtered_data[i].latitude;\n    var lng2 = stateMarker.filtered_data[i].longitude;\n    var alt_lng1 = lng1;\n    var alt_lng2 = lng2;\n\n    if (lng2 - lng1 <= -180) {\n      if (lng1 < 0) {\n        alt_lng1 = lng1 + 360;\n      } else if (lng2 < 0) {\n        alt_lng2 = lng2 + 360;\n      }\n\n      var distance = calculateDistance(lat1, lng1, lat2, lng2);\n      var alt_distance = calculateDistance(lat1, alt_lng1, lat2, alt_lng2);\n\n      if (alt_distance < distance) {\n        lng1 = alt_lng1;\n        lng2 = alt_lng2;\n      }\n    }\n\n    var coordinates = calculateCurve(lat1, lng1, lat2, lng2, factor);\n    L.curve(['M', coordinates['latlng1'], 'Q', coordinates['midpointLatLng'], coordinates['latlng2']], coordinates['pathOptions'], {\n      className: 'my-curve'\n    }).addTo(map);\n  }\n\n  return null;\n};\n\n_s(Arches, \"MSwarOdHxI5QI54a703war+9GWw=\", false, function () {\n  return [useLeaflet, useSelector];\n});\n\n_c = Arches;\nexport default Arches;\n\nvar _c;\n\n$RefreshReg$(_c, \"Arches\");","map":{"version":3,"sources":["C:/Users/Weilin/Documents/GitHub/InsectTrade/app/client/src/js/components/Arches.js"],"names":["useLeaflet","L","useSelector","haversine","Arches","map","stateMarker","state","marker","factor","factordelta","calculateCurve","lat1","lng1","lat2","lng2","weight","latlng1","latlng2","offsetX","offsetY","r","Math","sqrt","pow","theta","atan2","thetaOffset","r2","cos","theta2","midpointX","midpointY","sin","midpointLatLng","durationBase","duration","log","isNaN","pathOptions","opacity","calculateDistance","i","filtered_data","length","origin_latitude","origin_longitude","latitude","longitude","alt_lng1","alt_lng2","distance","alt_distance","coordinates","curve","className","addTo"],"mappings":"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","sourcesContent":["import { useLeaflet } from \"react-leaflet\";\r\nimport L from 'leaflet'\r\nimport '@elfalem/leaflet-curve'\r\nimport { useSelector } from \"react-redux\";\r\nimport haversine from 'haversine-distance';\r\n\r\nconst Arches = () => {\r\n    const { map } = useLeaflet();\r\n    const stateMarker = useSelector(state => state.marker);\r\n    var factor = 1;\r\n    const factordelta = 0.1\r\n\r\n    function calculateCurve(lat1, lng1, lat2, lng2, factor, weight) {\r\n        var latlng1 = [lat1,lng1];\r\n        var latlng2 = [lat2,lng2];\r\n        var offsetX = latlng2[1] - latlng1[1];\r\n        var offsetY = latlng2[0] - latlng1[0];\r\n\r\n        var r = Math.sqrt( Math.pow(offsetX, 2) + Math.pow(offsetY, 2) ),\r\n            theta = Math.atan2(offsetY, offsetX);\r\n\r\n        var thetaOffset = (3.14/10)*factor;\r\n\r\n        var r2 = (r/2)/(Math.cos(thetaOffset));\r\n        var theta2 = theta + thetaOffset;\r\n\r\n        var midpointX = (r2 * Math.cos(theta2)) + latlng1[1];\r\n        var midpointY = (r2 * Math.sin(theta2)) + latlng1[0];\r\n\r\n        var midpointLatLng = [midpointY, midpointX];\r\n\r\n        var durationBase = 2000;\r\n        var duration = Math.sqrt(Math.log(r)) * durationBase;\r\n        if (isNaN(duration)) {duration = durationBase}\r\n\r\n        var pathOptions = {\r\n            weight: weight,\r\n            opacity:0.15\r\n        }\r\n\r\n        /*pathOptions.animate = {\r\n            duration: duration,\r\n            iterations: Infinity,\r\n            easing: 'ease-in-out',\r\n            direction: 'normal'\r\n        }*/\r\n        return {'latlng1': latlng1, 'midpointLatLng': midpointLatLng, 'latlng2': latlng2, 'pathOptions': pathOptions}\r\n    }\r\n\r\n    function calculateDistance(lat1,lng1,lat2,lng2) {\r\n        return Math.sqrt(((lat1-lat2)**2) + ((lng1-lng2)**2))\r\n    }\r\n\r\n    for (var i = 0; i < stateMarker.filtered_data.length; i++) {\r\n        var lat1 = stateMarker.filtered_data[i].origin_latitude;\r\n        var lng1 = stateMarker.filtered_data[i].origin_longitude;\r\n        var lat2 = stateMarker.filtered_data[i].latitude;\r\n        var lng2 = stateMarker.filtered_data[i].longitude;\r\n        var alt_lng1 = lng1;\r\n        var alt_lng2 = lng2;\r\n\r\n        if ((lng2-lng1) <= -180) {\r\n            if (lng1 < 0) {alt_lng1 = lng1+360}\r\n            else if (lng2 < 0) {alt_lng2 = lng2+360}\r\n\r\n            var distance = calculateDistance(lat1,lng1,lat2,lng2)\r\n            var alt_distance = calculateDistance(lat1,alt_lng1,lat2,alt_lng2)\r\n\r\n            if (alt_distance < distance) {\r\n                lng1 = alt_lng1;\r\n                lng2 = alt_lng2\r\n            }\r\n        }\r\n\r\n        var coordinates = calculateCurve(lat1,lng1,lat2,lng2,factor);\r\n\r\n        L.curve(\r\n        [\r\n            'M', coordinates['latlng1'],\r\n            'Q', coordinates['midpointLatLng'],\r\n                 coordinates['latlng2']\r\n        ], coordinates['pathOptions'], {className: 'my-curve'}).addTo(map);\r\n    }\r\n\r\n    return null\r\n\r\n}\r\n\r\nexport default Arches;"]},"metadata":{},"sourceType":"module"}